(**The main interface for the Faugere package. *)

(** Internal Fgb exceptions*)
exception FgbE of string

(**{2:fgbtypes Fgb Types} *)


type fmonic = int list
(**A monic monomial is a list of integers representing the multi-degree of that monomial. 
For example, within k\[x, y, z\] for some field k, [x^2yz^3] would be \[[2; 1; 3]\], and [y^4z^2] would be \[[0; 4; 2]\].*)

type 'a fmon = 'a * fmonic
(**A monomial is a pair of a coefficient and a monic monomial.*)

(**{2:fgbopt Fgb options} *)

module type Fgb_opt = sig
(**Options that can be modified for the GB computation. *)

  val set_max_output_size : int -> unit
  (**Internally in fgb a buffer needs to be allocated to hold the output polynomials. The number of polynomials in the resulting GB cannot be larger than this value. Default is 100000.*)

  val set_index : int -> unit
  (**From the fgb doc. "This is is the maximal size of the matrices generated by F4
     you can increase this value according to your memory." Default is 500000.*)

  val set_fgb_verbosity : int -> unit
  (**Increase the verbosity of fgb. Default is 0 for least verbosity. 1 increases verbosity. Unfortunately, with 0 verbosity "open simulation" is still printed to stdout from somewhere in fgb. *)

  val set_force_elim : int -> unit
  (**If an elimination order is given to fgb and force_elim = 1, fgb will only return the polynomials in the elimination ideal. By default force_elim = 0.*)

  val set_number_of_threads : int -> unit
  (**Set the number of threads fgb will use. Default is 1.*)

end

(**{2:fgb Grobner basis implementations.} *)

module Fgb_int_str : sig
(**An implementation of fgb over the rationals. The coefficients are all infinite precision integers given as decimal strings. 
   These strings will get converted to gmp mpz values internally.*)

  include Fgb_opt

  val fgb : (string fmon list) list -> string list -> string list -> (string fmon list) list
  (**[fgb polys block1 block2] computes a Grobner basis of the polynomials in [polys] within the ring Q\[block1, block2\]. 
  The monomial order used in the computation is a block ordering defined by the variables in [block1] and [block2] with [block1] >> [block2]. That is,
  for any monomials m1 and m2 where, m1 contains variables in [block1] but m2 does not, m1>m2. The monomial order within each block is degree reverse
  lexicographic defined by the order of the variables in the given list. That is [fgb polys \["x"; "y"; "z"\] \[\]] defines a drl order with [x] > [y] > [z].
  As in the previous example [block2] can be empty, indicated a normal drl order. However, [block1] must be non-empty. For the input polynomials to be 
  well formed the integer lists representing each monic monomial need to have the same length as [block1 @ block2]. 
  @raise FgbE If Fgb throws exception. Most likely exceeded matrix bounds.*)

end

module Fgb_mod : sig
(**An implementation of fgb over a finite field. The coefficients are integers.*)

  include Fgb_opt

  val fgb : (int fmon list) list -> string list -> string list -> int -> (int fmon list) list
  (**[fgb polys block1 block2 p] is the same as {!val:Fgb_int_str.fgb} but with the added prime [p], defining the finite field of interest. I.e., Z mod p. *)

end

module Fgb_int : functor (C : sig type coef val coef_to_mpz : coef -> unit Ctypes.ptr val mpz_to_coef : unit Ctypes.ptr -> coef end) -> sig
  (**This functor can be instantiated to give an implementation of fgb over the rationals, but with the given type [coef] as coefficients. However, one must provide
  the translations from [coef] to a gmp mpz ptr and from an mpz ptr to [coef]. This is done in the optional library faugere.zarith, which uses zarith as the type of coefficients. *)
  
  include Fgb_opt

  val fgb : (C.coef fmon list) list -> string list -> string list -> (C.coef fmon list) list
  (**The same as {!val:Fgb_int_str.fgb} but where the input and output polynomials use the given coefficient type. *)
  
end

